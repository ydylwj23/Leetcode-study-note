## LeetCode link(Medium)
[LeetCode Link](https://leetcode.com/problems/increasing-triplet-subsequence/)
 
## Keyword
DP, greedy

## Problem description
```
Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.

 

Example 1:

Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
Example 2:

Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
Example 3:

Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
 

Constraints:

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
 

Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?

```
## 12/18/2020 Greedy, DP
```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int first_num = Integer.MAX_VALUE;
        int second_num = Integer.MAX_VALUE;
        for (int n: nums) {
            if (n <= first_num) {
                first_num = n;
            } else if (n <= second_num) {
                second_num = n;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

## Complexity Analyze
Time complexity: O(n)  
Space complexity: O(1)

## Notes
Use two variables to store the two smaller numbers on the left. The key here is that the order of these two numbers don't matter in the algorithm, even though it matters in the requirements.  

## Key points
Corner cases:   
API: